import os
import time
import streamlit as st
from pathlib import Path
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process, LLM
from crewai.tools import tool
import sqlite3
import pandas as pd
from datetime import datetime

# Importa a ferramenta RAR do arquivo separado
from tools.rar_tools import RarExtractorTool, create_rar_extractor_tool, check_extraction_tools

# Carrega as vari√°veis de ambiente
load_dotenv()

import warnings
warnings.filterwarnings("ignore", category=SyntaxWarning)
warnings.filterwarnings("ignore", module="pydantic")

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="I2A2 - An√°lise Inteligente de Notas Fiscais",
    page_icon="üóÇÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configura√ß√£o do LLM
@st.cache_resource
def get_llm():
    return LLM(
        model=os.getenv("MODEL", "gpt-4o-mini"),
        temperature=0.1,
        max_tokens=500,
        top_p=0.9,
        api_key=os.getenv("OPENAI_API_KEY")
    )

LLm = get_llm()

def get_raw_result(result):
    """Extrai o conte√∫do raw do resultado do CrewAI."""
    if hasattr(result, 'raw'):
        return result.raw
    elif hasattr(result, 'result'):
        return result.result
    else:
        return str(result)

def get_available_columns(db_path: str) -> dict:
    """Retorna as colunas dispon√≠veis no banco de dados e identifica o tipo"""
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("PRAGMA table_info(notas_fiscais)")
        columns = cursor.fetchall()
        conn.close()
        
        available_columns = [col[1].lower() for col in columns]
        
        # Detecta se √© arquivo de cabe√ßalhos ou itens
        is_header_file = 'valor_nota_fiscal' in available_columns
        is_items_file = 'valor_total' in available_columns and 'descricao_do_produto_servico' in available_columns
        
        return {
            'type': 'header' if is_header_file else 'items' if is_items_file else 'unknown',
            'valor_column': 'valor_nota_fiscal' if is_header_file else 'valor_total' if is_items_file else None,
            'has_products': 'descricao_do_produto_servico' in available_columns,
            'has_quantity': 'quantidade' in available_columns,
            'uf_emitente': 'uf_emitente' in available_columns,
            'razao_social_emitente': 'razao_social_emitente' in available_columns,
            'all_columns': available_columns
        }
        
    except Exception as e:
        return {'type': 'error', 'error': str(e)}

def get_database_statistics(db_path: str) -> dict:
    """Obt√©m estat√≠sticas adaptadas ao tipo de arquivo"""
    try:
        col_info = get_available_columns(db_path)
        
        if col_info['type'] == 'error':
            return {'error': col_info['error']}
        
        conn = sqlite3.connect(db_path)
        
        # Estat√≠sticas b√°sicas
        total_registros = pd.read_sql_query("SELECT COUNT(*) as total FROM notas_fiscais", conn).iloc[0]['total']
        
        # Valor total (adaptado ao tipo de arquivo)
        valor_total = 0
        if col_info['valor_column']:
            query = f"SELECT SUM({col_info['valor_column']}) as soma FROM notas_fiscais WHERE {col_info['valor_column']} IS NOT NULL"
            result = pd.read_sql_query(query, conn).iloc[0]['soma']
            valor_total = result or 0
        
        # Estados √∫nicos
        estados_unicos = 0
        if col_info['uf_emitente']:
            result = pd.read_sql_query("SELECT COUNT(DISTINCT uf_emitente) as estados FROM notas_fiscais WHERE uf_emitente IS NOT NULL", conn).iloc[0]['estados']
            estados_unicos = result or 0
        
        # Empresas √∫nicas
        empresas_unicas = 0
        if col_info['razao_social_emitente']:
            result = pd.read_sql_query("SELECT COUNT(DISTINCT razao_social_emitente) as empresas FROM notas_fiscais WHERE razao_social_emitente IS NOT NULL", conn).iloc[0]['empresas']
            empresas_unicas = result or 0
        
        # Estat√≠sticas espec√≠ficas por tipo
        extra_stats = {}
        
        if col_info['type'] == 'header':
            # Para arquivo de cabe√ßalhos
            extra_stats['tipo'] = 'Arquivo de Cabe√ßalhos (Notas Fiscais)'
            extra_stats['label_valor'] = 'Valor Total das NFs'
            extra_stats['label_registros'] = 'Total de Notas Fiscais'
            
            # M√©dia por nota fiscal
            if valor_total > 0 and total_registros > 0:
                extra_stats['valor_medio'] = valor_total / total_registros
        
        elif col_info['type'] == 'items':
            # Para arquivo de itens
            extra_stats['tipo'] = 'Arquivo de Itens (Produtos)'
            extra_stats['label_valor'] = 'Valor Total dos Itens'
            extra_stats['label_registros'] = 'Total de Itens'
            
            # Produtos √∫nicos
            if col_info['has_products']:
                result = pd.read_sql_query("SELECT COUNT(DISTINCT descricao_do_produto_servico) as produtos FROM notas_fiscais WHERE descricao_do_produto_servico IS NOT NULL", conn).iloc[0]['produtos']
                extra_stats['produtos_unicos'] = result or 0
        
        else:
            extra_stats['tipo'] = 'Tipo Desconhecido'
            extra_stats['label_valor'] = 'Valor Total'
            extra_stats['label_registros'] = 'Total de Registros'
        
        conn.close()
        
        return {
            'total_registros': total_registros,
            'valor_total': valor_total,
            'estados_unicos': estados_unicos,
            'empresas_unicas': empresas_unicas,
            'column_info': col_info,
            **extra_stats
        }
        
    except Exception as e:
        return {'error': str(e)}

def get_database_schema(db_path: str, info_type: str = "schema") -> str:
    """Fun√ß√£o auxiliar para obter informa√ß√µes do esquema"""
    try:
        conn = sqlite3.connect(db_path)
        
        if info_type.lower() == "schema":
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(notas_fiscais)")
            columns = cursor.fetchall()
            
            result = "ESQUEMA DA TABELA 'notas_fiscais':\n\n"
            for col in columns:
                result += f"- {col[1]} ({col[2]})\n"
            
            # Lista tamb√©m o total de registros
            cursor.execute("SELECT COUNT(*) FROM notas_fiscais")
            total = cursor.fetchone()[0]
            result += f"\nTotal de registros: {total}"
            
            conn.close()
            return result
            
        elif info_type.lower() == "sample":
            df = pd.read_sql_query("SELECT * FROM notas_fiscais LIMIT 3", conn)
            conn.close()
            return f"AMOSTRA DOS DADOS:\n\n{df.to_string(index=False)}"
            
    except Exception as e:
        return f"Erro ao obter informa√ß√µes: {str(e)}"

# Fun√ß√µes SQLite
def execute_sql_query(db_path: str, query: str) -> str:
    """Executa consulta SQL e retorna resultado formatado"""
    try:
        conn = sqlite3.connect(db_path)
        
        if query.strip().upper().startswith('SELECT'):
            df = pd.read_sql_query(query, conn)
            conn.close()
            
            if df.empty:
                return "Nenhum resultado encontrado."
            
            result = f"Encontrados {len(df)} registros:\n\n"
            result += df.to_string(index=False, max_rows=20)
            
            if len(df) > 20:
                result += f"\n\n... e mais {len(df) - 20} registros."
            
            return result
        else:
            cursor = conn.cursor()
            cursor.execute(query)
            conn.commit()
            rows_affected = cursor.rowcount
            conn.close()
            return f"Consulta executada. {rows_affected} linhas afetadas."
            
    except Exception as e:
        return f"Erro na consulta: {str(e)}"

def create_database_from_csv(csv_path: str, db_path: str) -> bool:
    """Converte CSV para SQLite com feedback detalhado"""
    try:
        # Carrega CSV
        df = pd.read_csv(csv_path, encoding='utf-8')
        original_rows = len(df)
        
        # Limpa nomes das colunas
        original_columns = df.columns.tolist()
        df.columns = [clean_column_name(col) for col in df.columns]
        cleaned_columns = df.columns.tolist()
        
        # Processa dados
        df = clean_data(df)
        processed_rows = len(df)
        
        # Salva no SQLite
        conn = sqlite3.connect(db_path)
        df.to_sql('notas_fiscais', conn, if_exists='replace', index=False)
        
        # Cria √≠ndices b√°sicos
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_data_emissao ON notas_fiscais(data_emissao);",
            "CREATE INDEX IF NOT EXISTS idx_uf_emitente ON notas_fiscais(uf_emitente);",
            "CREATE INDEX IF NOT EXISTS idx_valor_total ON notas_fiscais(valor_total);",
            "CREATE INDEX IF NOT EXISTS idx_produto ON notas_fiscais(descricao_do_produto_servico);"
        ]
        
        indexes_created = 0
        for index in indexes:
            try:
                conn.execute(index)
                indexes_created += 1
            except:
                pass
        
        # Verifica estat√≠sticas finais
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM notas_fiscais")
        final_count = cursor.fetchone()[0]
        
        # Verifica colunas espec√≠ficas antes de consultar
        available_cols = get_available_columns(db_path)
        
        estados_count = 0
        if available_cols['uf_emitente']:
            cursor.execute("SELECT COUNT(DISTINCT uf_emitente) FROM notas_fiscais WHERE uf_emitente IS NOT NULL")
            estados_count = cursor.fetchone()[0]
        
        total_value = 0
        if available_cols['valor_column']:
            cursor.execute(f"SELECT SUM({available_cols['valor_column']}) FROM notas_fiscais WHERE {available_cols['valor_column']} IS NOT NULL")
            total_value = cursor.fetchone()[0] or 0
        
        conn.close()
        
        # Log de sucesso com estat√≠sticas
        st.info(f"""
        üìä **Processamento conclu√≠do:**
        - Registros processados: {final_count:,}
        - Estados √∫nicos: {estados_count}
        - Valor total: R$ {total_value:,.2f}
        - √çndices criados: {indexes_created}/4
        - Colunas processadas: {len(cleaned_columns)}
        """)
        
        return True
        
    except Exception as e:
        st.error(f"Erro ao criar banco: {str(e)}")
        return False

def clean_column_name(col_name: str) -> str:
    """Limpa nome da coluna para uso no SQL"""
    return (col_name.lower()
            .replace(' ', '_')
            .replace('/', '_')
            .replace('-', '_')
            .replace('(', '')
            .replace(')', '')
            .replace('√ß', 'c')
            .replace('√£', 'a')
            .replace('√µ', 'o'))

def clean_data(df: pd.DataFrame) -> pd.DataFrame:
    """Prepara os dados"""
    
    # Converte data
    if 'data_emissao' in df.columns:
        df['data_emissao'] = pd.to_datetime(df['data_emissao'], errors='coerce')
        df['ano'] = df['data_emissao'].dt.year
        df['mes'] = df['data_emissao'].dt.month
        df['dia_semana'] = df['data_emissao'].dt.day_name()
    
    # Valores num√©ricos - verifica se as colunas existem antes
    numeric_columns = ['quantidade', 'valor_unitario', 'valor_total', 'valor_nota_fiscal']
    for col in numeric_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
    
    return df

# Tools para CrewAI
def create_database_tools(db_path: str):
    """Cria as tools para acesso ao banco de dados"""
    
    @tool("nf_database_tool")
    def query_database(query: str) -> str:
        """
        Ferramenta para consultas SQL no banco de dados de notas fiscais.
        
        ESQUEMA DIN√ÇMICO DO BANCO:
        
        ARQUIVO DE CABE√áALHOS (se aplic√°vel):
        - chave_de_acesso, modelo, serie, numero
        - natureza_da_operacao, data_emissao 
        - razao_social_emitente, uf_emitente, municipio_emitente
        - nome_destinatario, uf_destinatario
        - valor_nota_fiscal (em vez de valor_total)
        - consumidor_final, presenca_do_comprador
        
        ARQUIVO DE ITENS (se aplic√°vel):
        - chave_de_acesso, data_emissao, ano, mes, dia_semana
        - razao_social_emitente, uf_emitente, municipio_emitente  
        - nome_destinatario, uf_destinatario
        - descricao_do_produto_servico, ncm_sh_tipo_de_produto
        - quantidade, valor_unitario, valor_total
        - cfop, natureza_da_operacao
        
        IMPORTANTE: 
        - Use valor_nota_fiscal para arquivos de cabe√ßalho
        - Use valor_total para arquivos de itens
        - Nem todos os arquivos t√™m todas as colunas
        
        Args:
            query: Consulta SQL para executar
            
        Returns:
            Resultado da consulta formatado
        """
        return execute_sql_query(db_path, query)

    @tool("nf_schema_info_tool") 
    def get_schema_info(info_type: str = "schema") -> str:
        """
        Obt√©m informa√ß√µes sobre o esquema do banco de dados.
        
        Args:
            info_type: Tipo de informa√ß√£o ('schema', 'sample', ou 'columns')
            
        Returns:
            Informa√ß√µes sobre o esquema, dados de exemplo ou detalhes das colunas
        """
        if info_type == "columns":
            col_info = get_available_columns(db_path)
            if col_info['type'] == 'error':
                return f"Erro ao obter colunas: {col_info['error']}"
            
            result = f"TIPO DE ARQUIVO: {col_info['type'].upper()}\n\n"
            result += "COLUNAS DISPON√çVEIS:\n"
            for col in col_info['all_columns']:
                result += f"- {col}\n"
            
            if col_info['type'] == 'header':
                result += "\nNOTA: Este √© um arquivo de CABE√áALHOS - use 'valor_nota_fiscal' para valores monet√°rios"
            elif col_info['type'] == 'items':
                result += "\nNOTA: Este √© um arquivo de ITENS - use 'valor_total' para valores monet√°rios"
            
            return result
        else:
            return get_database_schema(db_path, info_type)
    
    return query_database, get_schema_info

@st.cache_resource
def create_rar_extractor_agent():
    """Cria o agente de extra√ß√£o RAR com a ferramenta personalizada."""
    rar_tool = create_rar_extractor_tool()
    
    return Agent(
        role='Especialista em Descompacta√ß√£o RAR',
        goal='Descompactar arquivos RAR na pasta dados usando ferramentas especializadas',
        backstory="""
        Voc√™ √© um especialista em descompacta√ß√£o de arquivos RAR equipado com ferramentas 
        especializadas. Sua fun√ß√£o √© usar a ferramenta 'rar_extractor' para extrair 
        arquivos RAR na pasta 'dados', sempre verificando se o arquivo existe e 
        fornecendo feedback detalhado sobre o processo.
        
        Quando receber uma tarefa para extrair um arquivo RAR, voc√™ deve:
        1. Usar a ferramenta rar_extractor com o caminho do arquivo especificado
        2. A ferramenta criar√° automaticamente a pasta 'dados' se necess√°rio
        3. Relatar os resultados da opera√ß√£o de forma clara e detalhada
        
        IMPORTANTE: Sempre use a ferramenta rar_extractor para realizar a extra√ß√£o!
        """,
        verbose=False,  
        allow_delegation=False,
        tools=[rar_tool],
        llm=LLm
    )

def create_csv_analyzer_agent(db_path: str):
    """Cria o agente de an√°lise usando SQLite."""
    query_tool, schema_tool = create_database_tools(db_path)
    
    # Detecta o tipo de arquivo para ajustar o backstory
    col_info = get_available_columns(db_path)
    file_type_info = ""
    
    if col_info['type'] == 'header':
        file_type_info = """
        IMPORTANTE: Voc√™ est√° analisando um arquivo de CABE√áALHOS de notas fiscais.
        - Use 'valor_nota_fiscal' para valores monet√°rios (n√£o 'valor_total')
        - Cada registro representa uma NOTA FISCAL completa
        - N√ÉO h√° informa√ß√µes de produtos individuais
        - Foque em an√°lises de notas fiscais, empresas, fluxo entre estados
        """
    elif col_info['type'] == 'items':
        file_type_info = """
        IMPORTANTE: Voc√™ est√° analisando um arquivo de ITENS de notas fiscais.
        - Use 'valor_total' e 'valor_unitario' para valores monet√°rios
        - Cada registro representa um ITEM/PRODUTO de uma nota fiscal
        - H√Å informa√ß√µes detalhadas de produtos (descri√ß√£o, NCM, quantidade)
        - Pode fazer an√°lises de produtos, ranking de vendas por item
        """
    
    return Agent(
        role='Especialista SQL em Dados Fiscais',
        goal='Converter perguntas em consultas SQL precisas no banco de notas fiscais',
        backstory=f"""Voc√™ √© um especialista em an√°lise de dados fiscais e SQL com profundo 
        conhecimento sobre notas fiscais eletr√¥nicas. Voc√™ entende perfeitamente o esquema 
        do banco de dados de notas fiscais e consegue traduzir qualquer pergunta de neg√≥cio 
        em consultas SQL otimizadas.
        
        {file_type_info}
        
        Suas especialidades incluem:
        - Consultas de agrega√ß√£o (SUM, COUNT, AVG, GROUP BY)
        - An√°lises temporais (por data, m√™s, ano, dia da semana)
        - An√°lises geogr√°ficas (por UF, munic√≠pio)
        - An√°lises de produtos (quando dispon√≠vel)
        - An√°lises de opera√ß√µes (CFOP, natureza da opera√ß√£o)
        
        SEMPRE use get_schema_info com par√¢metro 'columns' PRIMEIRO para entender 
        exatamente quais colunas est√£o dispon√≠veis antes de gerar consultas SQL.""",
        tools=[query_tool, schema_tool],
        verbose=False,
        allow_delegation=False,
        llm=LLm
    )

def create_business_analyst_agent():
    """Cria o agente analista de neg√≥cios."""
    return Agent(
        role='Analista de Neg√≥cios Fiscais',
        goal='Interpretar resultados de consultas SQL e fornecer insights de neg√≥cio relevantes',
        backstory="""Voc√™ √© um analista de neg√≥cios especializado em interpretar 
        dados fiscais para gerar insights estrat√©gicos. Voc√™ consegue transformar 
        n√∫meros em hist√≥rias e recomenda√ß√µes pr√°ticas.
        
        Suas compet√™ncias incluem:
        - Interpreta√ß√£o de tend√™ncias de vendas
        - An√°lise de performance por regi√£o
        - Identifica√ß√£o de oportunidades de mercado
        - An√°lise de sazonalidade
        - Recomenda√ß√µes estrat√©gicas baseadas em dados
        - Identifica√ß√£o de riscos e oportunidades
        
        Voc√™ sempre fornece contexto e significado aos n√∫meros apresentados.""",
        verbose=False,
        llm=LLm
    )

def create_extraction_task(rar_filename: str, agent: Agent) -> Task:
    """Cria uma task para extra√ß√£o de RAR."""
    return Task(
        description=f"""
        Use a ferramenta rar_extractor para extrair o arquivo RAR '{rar_filename}' 
        para a pasta 'dados'.
        
        Instru√ß√µes:
        1. Execute a ferramenta rar_extractor com os seguintes par√¢metros:
           - rar_file_path: '{rar_filename}'
           - destination_folder: 'dados'
        
        2. A ferramenta ir√°:
           - Verificar se o arquivo '{rar_filename}' existe
           - Criar a pasta 'dados' se necess√°rio
           - Extrair todos os arquivos mantendo a estrutura
           - Contar os arquivos extra√≠dos
        
        3. Relate o resultado da opera√ß√£o de forma detalhada
        
        IMPORTANTE: Use APENAS a ferramenta rar_extractor para esta tarefa!
        """,
        expected_output=f"""
        Relat√≥rio completo da extra√ß√£o do arquivo '{rar_filename}' contendo:
        - Confirma√ß√£o de que a ferramenta rar_extractor foi utilizada
        - Status da opera√ß√£o (sucesso ou falha)
        - Caminho completo da pasta de destino
        - N√∫mero total de arquivos extra√≠dos
        - Detalhes de qualquer erro encontrado
        - Confirma√ß√£o de que a pasta 'dados' foi criada/utilizada
        """,
        agent=agent
    )

def create_analysis_task(pergunta: str, sql_agent: Agent, business_agent: Agent) -> tuple:
    """Cria tasks para an√°lise SQL e de neg√≥cios."""
    
    sql_task = Task(
        description=f"""
        Pergunta do usu√°rio: "{pergunta}"
        
        Voc√™ deve:
        1. Se necess√°rio, use get_schema_info para ver o esquema
        2. Analise a pergunta e identifique dados necess√°rios
        3. Gere consulta SQL apropriada usando query_database
        4. Execute a consulta e organize os resultados
        
        REGRAS:
        - Use nomes corretos das colunas
        - Para an√°lises temporais: ano, mes, dia_semana
        - Para valores monet√°rios: valor_total
        - Para geografia: uf_emitente, uf_destinatario  
        - Para produtos: descricao_do_produto_servico
        - Use LIMIT quando apropriado
        - Use ORDER BY para organizar resultados
        """,
        agent=sql_agent,
        expected_output="Consulta SQL executada com dados organizados"
    )
    
    business_task = Task(
        description=f"""
        Com base nos dados extra√≠dos para "{pergunta}", 
        forne√ßa an√°lise de neg√≥cio completa.
        
        Inclua:
        - Resumo dos principais achados
        - Interpreta√ß√£o dos n√∫meros
        - Insights e tend√™ncias
        - Recomenda√ß√µes quando apropriado
        """,
        agent=business_agent,
        expected_output="An√°lise de neg√≥cio com insights pr√°ticos",
        context=[sql_task]
    )
    
    return sql_task, business_task

def find_csv_files():
    """Encontra todos os arquivos CSV na pasta dados."""
    dados_path = Path("dados")
    if not dados_path.exists():
        return []
    
    csv_files = list(dados_path.glob("*.csv"))
    return [f.name for f in csv_files]

def find_db_files():
    """Encontra todos os arquivos SQLite na pasta dados."""
    dados_path = Path("dados")
    if not dados_path.exists():
        return []
    
    db_files = list(dados_path.glob("*.db"))
    return [f.name for f in db_files]

def save_uploaded_file(uploaded_file, destination_folder="dados"):
    """Salva o arquivo enviado na pasta especificada."""
    destination_path = Path(destination_folder)
    destination_path.mkdir(parents=True, exist_ok=True)
    
    file_path = destination_path / uploaded_file.name
    
    with open(file_path, "wb") as f:
        f.write(uploaded_file.getbuffer())
    
    return str(file_path)

def execute_with_retry(crew, inputs=None):
    """Executa a crew com retry em caso de rate limit."""
    try:
        if inputs:
            return crew.kickoff(inputs=inputs)
        else:
            return crew.kickoff()
    except Exception as e:
        if "rate_limit_exceeded" in str(e):
            st.warning("‚è≥ Rate limit excedido. Aguardando 60 segundos...")
            time.sleep(60)
            if inputs:
                return crew.kickoff(inputs=inputs)
            else:
                return crew.kickoff()
        else:
            raise e

def main():
    # Header
    st.title("üóÇÔ∏è I2A2 - An√°lise Inteligente de Notas Fiscais")
    st.markdown("### Sistema avan√ßado com SQLite para extra√ß√£o de arquivos RAR e an√°lise de dados de notas fiscais")
    
    # Sidebar
    st.sidebar.title("‚öôÔ∏è Configura√ß√µes")
    
    # Verifica√ß√£o da API Key
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        st.sidebar.error("‚ùå OPENAI_API_KEY n√£o configurada!")
        st.sidebar.info("Configure sua API key no arquivo .env")
        return
    else:
        st.sidebar.success("‚úÖ API Key configurada")
    
    # Status da pasta dados
    dados_path = Path("dados")
    if dados_path.exists():
        csv_files = find_csv_files()
        db_files = find_db_files()
        st.sidebar.info(f"üìÅ Pasta dados: {len(csv_files)} CSV, {len(db_files)} DB")
        
        # Mostra bancos dispon√≠veis para an√°lise
        if db_files:
            st.sidebar.success("üóÑÔ∏è **Bancos prontos para an√°lise:**")
            for db_file in db_files:
                st.sidebar.write(f"   üìä {db_file}")
        else:
            st.sidebar.warning("‚è≥ Nenhum banco pronto ainda")
    else:
        st.sidebar.warning("üìÅ Pasta dados n√£o existe")
    
    # Verifica ferramentas de extra√ß√£o RAR
    rar_status = check_extraction_tools()
    if rar_status["available"]:
        st.sidebar.success(f"üîß Ferramenta RAR: {os.path.basename(rar_status['command'])}")
    else:
        st.sidebar.error("üîß Nenhuma ferramenta RAR encontrada")
        st.sidebar.warning("Instale WinRAR ou 7-Zip")
    
    # Tabs
    tab1, tab2, tab3 = st.tabs(["üì§ Upload & Extra√ß√£o", "üìä An√°lise", "üìã Hist√≥rico"])
    
    with tab1:
        st.header("üì§ Upload e Extra√ß√£o de Arquivo RAR")
        
        # Upload do arquivo RAR
        uploaded_rar = st.file_uploader(
            "Selecione um arquivo RAR", 
            type=['rar'],
            help="Selecione o arquivo RAR que cont√©m os dados para an√°lise"
        )
        
        if uploaded_rar is not None:
            st.success(f"‚úÖ Arquivo selecionado: {uploaded_rar.name}")
            
            if st.button("üöÄ Descompactar o arquivo", type="primary", key="process_rar_button"):
                
                with st.spinner("Salvando arquivo..."):
                    # Salva o arquivo na pasta dados
                    rar_path = save_uploaded_file(uploaded_rar, "dados")
                    st.success(f"‚úÖ Arquivo salvo em: {rar_path}")
                
                with st.spinner("Extraindo arquivo RAR..."):
                    try:
                        # Cria o agente extrator
                        rar_agent = create_rar_extractor_agent()
                        extraction_task = create_extraction_task(rar_path, rar_agent)
                        
                        extraction_crew = Crew(
                            agents=[rar_agent],
                            tasks=[extraction_task],
                            verbose=False
                        )
                        
                        # Executa a extra√ß√£o
                        extraction_result = extraction_crew.kickoff()
                        
                        # Extrai apenas o conte√∫do raw
                        extraction_raw = get_raw_result(extraction_result)
                        
                        # Verifica se a extra√ß√£o foi bem-sucedida
                        success_indicators = [
                            "‚úÖ" in extraction_raw,
                            "Sucesso" in extraction_raw,
                            "sucesso" in extraction_raw,
                            "extra√≠dos" in extraction_raw,
                            "Arquivos extra√≠dos" in extraction_raw
                        ]
                        
                        error_indicators = [
                            "‚ùå" in extraction_raw,
                            "Erro" in extraction_raw,
                            "erro" in extraction_raw,
                            "falha" in extraction_raw,
                            "Falha" in extraction_raw
                        ]
                        
                        # Verifica se h√° arquivos CSV na pasta dados ap√≥s extra√ß√£o
                        csv_files_after = find_csv_files()
                        extraction_created_files = len(csv_files_after) > 0
                        
                        if any(success_indicators) and not any(error_indicators) or extraction_created_files:
                            st.success("üéâ Extra√ß√£o conclu√≠da com sucesso!")
                            
                            if extraction_created_files:
                                st.balloons()
                                st.success(f"üì¶ Arquivo RAR descompactado com sucesso!")
                                st.info(f"üìä {len(csv_files_after)} arquivo(s) CSV encontrado(s):")
                                
                                for csv_file in csv_files_after:
                                    st.write(f"   üìÑ {csv_file}")
                                
                                # PROCESSAMENTO AUTOM√ÅTICO DOS CSVs
                                st.markdown("---")
                                st.info("üîÑ **Processando arquivos CSV automaticamente...**")
                                
                                processed_count = 0
                                failed_count = 0
                                
                                for csv_file in csv_files_after:
                                    with st.spinner(f"Processando {csv_file}..."):
                                        csv_path = f"dados/{csv_file}"
                                        db_name = csv_file.replace('.csv', '.db')
                                        db_path = f"dados/{db_name}"
                                        
                                        if create_database_from_csv(csv_path, db_path):
                                            st.success(f"‚úÖ Banco criado: {db_name}")
                                            processed_count += 1
                                            
                                            # Mostra informa√ß√µes do banco
                                            schema_info = get_database_schema(db_path, "schema")
                                            with st.expander(f"üìã Informa√ß√µes do banco {db_name}"):
                                                st.code(schema_info, language="text")
                                        else:
                                            st.error(f"‚ùå Falha ao processar: {csv_file}")
                                            failed_count += 1
                                
                                # Resumo do processamento
                                st.markdown("---")
                                if processed_count > 0:
                                    st.success(f"üéâ **Processamento conclu√≠do!**")
                                    st.success(f"‚úÖ {processed_count} banco(s) SQLite criado(s) com sucesso!")
                                    if failed_count > 0:
                                        st.warning(f"‚ö†Ô∏è {failed_count} arquivo(s) falharam no processamento")
                                    
                                    st.markdown("---")
                                    st.success("‚úÖ **Sistema pronto!** V√° para a aba 'An√°lise' para fazer perguntas sobre os dados!")
                                else:
                                    st.error("‚ùå Nenhum arquivo p√¥de ser processado")
                            
                            with st.expander("üìã Ver detalhes da extra√ß√£o"):
                                st.code(extraction_raw, language="text")
                            
                            st.session_state['extraction_success'] = True
                            st.rerun()
                            
                        else:
                            st.error("‚ùå Falha na extra√ß√£o")
                            st.code(extraction_raw, language="text")
                            
                    except Exception as e:
                        st.error(f"‚ùå Erro durante a extra√ß√£o: {str(e)}")
    
    with tab2:
        st.header("üìä An√°lise Inteligente de Dados")
        
        # Lista os bancos SQLite dispon√≠veis
        db_files = find_db_files()
        
        if not db_files:
            st.warning("üóÑÔ∏è Nenhum banco de dados encontrado na pasta dados.")
            st.info("Fa√ßa o upload e extra√ß√£o de um arquivo RAR primeiro.")
        else:
            # Sele√ß√£o do banco de dados
            selected_db = st.selectbox(
                "üóÑÔ∏è Selecione o banco de dados para an√°lise:",
                db_files,
                index=0
            )
            
            db_path = f"dados/{selected_db}"
            
            # Estat√≠sticas r√°pidas do banco selecionado
            st.markdown("### üìà Estat√≠sticas R√°pidas")
            
            stats = get_database_statistics(db_path)
            
            if 'error' in stats:
                st.warning(f"N√£o foi poss√≠vel carregar estat√≠sticas: {stats['error']}")
            else:
                # Mostra o tipo de arquivo
                if 'tipo' in stats:
                    st.info(f"üìã **{stats['tipo']}**")
                
                # Exibe m√©tricas adaptadas
                if stats['column_info']['type'] == 'header':
                    # M√©tricas para arquivo de cabe√ßalhos
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("üìÑ Total de Notas Fiscais", f"{stats['total_registros']:,}")
                    
                    with col2:
                        st.metric("üí∞ Valor Total das NFs", f"R$ {stats['valor_total']:,.2f}")
                    
                    with col3:
                        st.metric("üó∫Ô∏è Estados Emitentes", stats['estados_unicos'])
                    
                    with col4:
                        if 'valor_medio' in stats:
                            st.metric("üìä Valor M√©dio por NF", f"R$ {stats['valor_medio']:,.2f}")
                        else:
                            st.metric("üè¢ Empresas", stats['empresas_unicas'])
                
                elif stats['column_info']['type'] == 'items':
                    # M√©tricas para arquivo de itens
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("üì¶ Total de Itens", f"{stats['total_registros']:,}")
                    
                    with col2:
                        st.metric("üí∞ Valor Total dos Itens", f"R$ {stats['valor_total']:,.2f}")
                    
                    with col3:
                        if 'produtos_unicos' in stats:
                            st.metric("üìã Produtos √önicos", stats['produtos_unicos'])
                        else:
                            st.metric("üó∫Ô∏è Estados", stats['estados_unicos'])
                    
                    with col4:
                        st.metric("üè¢ Empresas", stats['empresas_unicas'])
                
                else:
                    # M√©tricas gen√©ricas
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("üìä Total de Registros", f"{stats['total_registros']:,}")
                    
                    with col2:
                        if stats['valor_total'] > 0:
                            st.metric("üí∞ Valor Total", f"R$ {stats['valor_total']:,.2f}")
                        else:
                            st.metric("üí∞ Valor Total", "N/A")
                    
                    with col3:
                        st.metric("üó∫Ô∏è Estados", stats['estados_unicos'])
                    
                    with col4:
                        st.metric("üè¢ Empresas", stats['empresas_unicas'])
            
            st.markdown("---")
            
            # Mostra informa√ß√µes do banco selecionado
            with st.expander("üìã Informa√ß√µes do Banco de Dados"):
                schema_info = get_database_schema(db_path, "schema")
                st.code(schema_info, language="text")
                
                sample_info = get_database_schema(db_path, "sample")
                st.code(sample_info, language="text")
            
            # Campo para a pergunta
            pergunta = st.text_area(
                "‚ùì Digite sua pergunta sobre os dados:",
                placeholder="Ex: Quais s√£o os 5 produtos mais vendidos por valor total?\nQual foi o faturamento por estado emitente?\nComo est√£o distribu√≠das as vendas por m√™s?",
                height=100
            )
            
            # Sugest√µes de perguntas adaptadas ao tipo de arquivo
            col_info = get_available_columns(db_path)
            
            st.markdown("üí° **Sugest√µes de perguntas:**")
            
            col1, col2 = st.columns(2)
            
            if col_info['type'] == 'header':
                # Sugest√µes para arquivo de cabe√ßalhos
                with col1:
                    st.markdown("""
                    **üìÑ An√°lises de Notas Fiscais:**
                    - Qual foi o valor total das notas fiscais?
                    - Quantas notas fiscais foram emitidas?
                    - Qual √© o valor m√©dio por nota fiscal?
                    - Quais empresas emitiram mais notas?
                    
                    **üìÖ An√°lises Temporais:**
                    - Como est√£o distribu√≠das as emiss√µes por m√™s?
                    - Qual dia da semana tem mais emiss√µes?
                    - Evolu√ß√£o das emiss√µes ao longo do tempo
                    """)
                
                with col2:
                    st.markdown("""
                    **üó∫Ô∏è An√°lises Geogr√°ficas:**
                    - Quais estados mais emitem notas fiscais?
                    - Para quais estados as notas s√£o destinadas?
                    - Fluxo de notas fiscais entre estados
                    
                    **üè¢ An√°lises de Empresas:**
                    - Ranking de empresas por valor de notas
                    - Empresas por quantidade de notas emitidas
                    - An√°lise por natureza da opera√ß√£o
                    """)
                
                # Bot√µes de exemplo para cabe√ßalhos
                example_questions = [
                    "Qual foi o valor total das notas fiscais?",
                    "Quais empresas emitiram mais notas fiscais?",
                    "Como est√£o distribu√≠das as emiss√µes por estado?",
                    "Qual √© o valor m√©dio por nota fiscal?"
                ]
            
            elif col_info['type'] == 'items':
                # Sugest√µes para arquivo de itens
                with col1:
                    st.markdown("""
                    **üì¶ An√°lises de Produtos:**
                    - Quais s√£o os 10 produtos mais vendidos?
                    - Produtos com maior valor unit√°rio
                    - An√°lise por tipo de NCM
                    - Ranking por quantidade vendida
                    
                    **üí∞ An√°lises Financeiras:**
                    - Valor total de vendas por produto
                    - Valor m√©dio por item
                    - Produtos mais lucrativos
                    """)
                
                with col2:
                    st.markdown("""
                    **üó∫Ô∏è An√°lises Geogr√°ficas:**
                    - Vendas por estado de origem
                    - Principais destinos por produto
                    - Fluxo de produtos entre estados
                    
                    **üìä An√°lises Operacionais:**
                    - An√°lise por CFOP
                    - Natureza das opera√ß√µes
                    - Quantidade vs Valor
                    """)
                
                # Bot√µes de exemplo para itens
                example_questions = [
                    "Quais s√£o os 5 produtos mais vendidos por valor?",
                    "Qual foi o faturamento total por estado?",
                    "Quais produtos t√™m maior valor unit√°rio?",
                    "Como est√£o distribu√≠das as vendas por NCM?"
                ]
            
            else:
                # Sugest√µes gen√©ricas
                with col1:
                    st.markdown("""
                    **üìä An√°lises B√°sicas:**
                    - Qual o total de registros?
                    - Distribui√ß√£o por estado
                    - An√°lise temporal dos dados
                    """)
                
                with col2:
                    st.markdown("""
                    **üîç An√°lises Explorat√≥rias:**
                    - Principais empresas
                    - Padr√µes nos dados
                    - Estat√≠sticas gerais
                    """)
                
                example_questions = [
                    "Quantos registros temos no total?",
                    "Quais s√£o os principais estados?",
                    "Como est√£o distribu√≠dos os dados?",
                    "Quais s√£o as principais empresas?"
                ]
            
            # Bot√µes de exemplo
            st.markdown("üöÄ **Clique para testar:**")
            cols = st.columns(2)
            for i, question in enumerate(example_questions):
                with cols[i % 2]:
                    if st.button(f"üí≠ {question[:30]}...", key=f"example_{i}"):
                        pergunta = question
                        st.rerun()
            
            # Bot√£o para iniciar a an√°lise
            if st.button("üîç Analisar Dados", type="primary", key="analyze_button"):
                if not pergunta:
                    st.warning("‚ö†Ô∏è Por favor, digite uma pergunta antes de analisar.")
                else:
                    with st.spinner("ü§ñ Processando com IA avan√ßada..."):
                        try:
                            # Cria os agentes
                            sql_agent = create_csv_analyzer_agent(db_path)
                            business_agent = create_business_analyst_agent()
                            
                            # Cria as tasks
                            sql_task, business_task = create_analysis_task(pergunta, sql_agent, business_agent)
                            
                            analysis_crew = Crew(
                                name="Tripula√ß√£o de An√°lise Inteligente",
                                agents=[sql_agent, business_agent],
                                tasks=[sql_task, business_task],
                                process=Process.sequential,
                                verbose=False
                            )
                            
                            # Executa a an√°lise
                            analysis_result = execute_with_retry(analysis_crew, {"pergunta": pergunta})
                            
                            # Extrai apenas o conte√∫do raw
                            analysis_raw = get_raw_result(analysis_result)
                            
                            # Exibe o resultado
                            st.success("‚úÖ An√°lise conclu√≠da!")
                            st.markdown("### üìã Resultado da An√°lise:")
                            st.write(analysis_raw)
                            
                            # Salva no hist√≥rico
                            if 'analysis_history' not in st.session_state:
                                st.session_state['analysis_history'] = []
                            
                            st.session_state['analysis_history'].append({
                                'pergunta': pergunta,
                                'banco': selected_db,
                                'resultado': analysis_raw,
                                'timestamp': time.strftime("%Y-%m-%d %H:%M:%S")
                            })
                            
                        except Exception as e:
                            st.error(f"‚ùå Erro durante a an√°lise: {str(e)}")
                            st.exception(e)
    
    with tab3:
        st.header("üìã Hist√≥rico de An√°lises")
        
        if 'analysis_history' in st.session_state and st.session_state['analysis_history']:
            for i, analysis in enumerate(reversed(st.session_state['analysis_history'])):
                with st.expander(f"üìä An√°lise {len(st.session_state['analysis_history']) - i} - {analysis['timestamp']}"):
                    st.write(f"**Banco:** {analysis['banco']}")
                    st.write(f"**Pergunta:** {analysis['pergunta']}")
                    st.write(f"**Resultado:**")
                    st.write(analysis['resultado'])
            
            if st.button("üóëÔ∏è Limpar Hist√≥rico", key="clear_history_button"):
                st.session_state['analysis_history'] = []
                st.success("‚úÖ Hist√≥rico limpo!")
                st.rerun()
        else:
            st.info("üìù Nenhuma an√°lise realizada ainda.")
            st.write("As an√°lises aparecer√£o aqui conforme voc√™ for utilizando o sistema.")

if __name__ == "__main__":
    main()